# frozen_string_literal: true

require_relative "rfc3454_table_parser"
require_relative "stringprep_table_transformer"

# Generator for stringprep StringPrep::Tables constants (primarily regexps).
#
# Combines Unicode character classes with generated tables.  Generated regexps
# are still used to test that the written regexps conform to the specification.
# Some tables don't match up well with any character properties available to
# ruby's regexp engine.  Those use the table-generated regexps.
class StringPrepTablesGenerator
  INDENT = "  "

  attr_reader :tables_dir, :transformer

  def initialize(tables_dir: "lib/net/imap/stringprep/tables")
    @parser      = RFC3454TableParser.new
    @transformer = StringPrepTableTransformer.new(self)
    @tables_dir  = tables_dir
  end

  def inspect; "#<#{self.class}>" end

  def asgn_regexps; @asgn_regexps ||  asgn_regexps! end
  def consts;       @consts       ||= define_consts end

  # delegated to @parser
  def json_filename; @parser.json_filename end
  def tables;        @parser.tables        end
  def titles;        @parser.titles        end
  def table_names;   @parser.table_names   end
  def mapping_names; @parser.mapping_names end

  # for rake deps
  def json_deps;   @parser.rake_deps   end
  def clean_deps;  @parser.rake_output end # TODO: add table files to this list?
  def generate_json_data_file; @parser.write_json_file! end

  # delegated to @transformer
  def merged_tables_regex(...) @transformer.merged_tables_regex(...) end

  # for rake deps
  def rb_deps;     Rake::FileList[json_deps, clean_deps, __FILE__] end
  def table_files; consts.each_key.map { "#{tables_dir}/#{_1.downcase}.rb" } end

  def regexp_for(*names, negate: false)
    asgn_regexps[[*names, negate]] ||= merged_tables_regex(*names, negate: negate)
  end

  def stringprep_rb
    stringprep_tables_file_template do
      consts.each_key.map {|name|
        'autoload %-26s "#{__dir__}/tables/%s.rb"' % [
          name.to_sym.inspect + ",",
          name.downcase
        ]
      }.join("\n")
    end
  end

  def stringprep_table_file(const_name)
    stringprep_tables_file_template {
      value = consts.fetch(const_name)
      case value
      in {table:, negate:, regexp: Regexp}
        asgn_table table, negate: negate
      in {table:, map: Hash | String | Proc}
        asgn_mapping table
      in {comment:, union:}
        "%s\n%s =\n  Regexp.union(%s).freeze" % [
          comment.gsub(/^/, "# "), const_name, union,
        ]
      in {comment:, regexp:}
        "%s\n%s = %p.freeze" % [
          comment.gsub(/^/, "# "), const_name, regexp,
        ]
      in {comment:, hash:, literals:}
        "%s\n%s = {\n%s\n}.freeze" % [
          comment.gsub(/^/, "# "),
          const_name,
          hash_contents(hash, literals: literals),
        ]
      in String => str
        "%s = %p" % [const_name, str]
      end
    }
  end

  def stringprep_tables_file_template
    content = indent yield.strip, level: 2
    <<~RUBY
      # frozen_string_literal: true

      #--
      # This file is generated by `rake stringprep:tables`.  Don't edit directly.
      #++

      module Net::IMAP::StringPrep
        module Tables

          #{content.strip}

        end
      end
    RUBY
  end

  def hash_contents(hash, literals: false, indent: 1)
    keylen = hash.keys.map(&:inspect).map(&:length).max
    format = "%-#{keylen}p => %#{literals ? ?s : ?p},"
    indent hash.map {|kv| format % kv }.join("\n"), level: indent
  end

  def tables_to_const_names
    asgn_regexps
      .reject {|(_table, negate), _regexp| negate }
      .to_h   {|(table, _negate), _regexp| [table, regexp_const_name(table)] }
  end

  def table_regexps_rb(indent = 3)
    tables_to_const_names
      .map {|table, const| "%-7p => %s," % [table, const] }
      .join("\n")
  end

  private

  def define_consts
    {}.merge!(table_regexp_consts,
              table_mappings_consts,
              bidi_failure_consts,
              *profile_consts,
              meta_consts)
  end

  def table_regexp_consts
    asgn_regexps.to_h {|(t, n), r|
      [regexp_const_name(t, negate: n), {table: t, negate: n, regexp: r}]
    }
  end

  def table_mappings_consts
    @parser.mapping_tables.to_h {|table, map|
      [mapping_const_name(table), {table: table, map: map}]
    }
  end

  def bidi_failure_consts
    {
      BIDI_DESC_REQ2: "A string with RandALCat characters " \
                      "must not contain LCat characters.",
      BIDI_FAILS_REQ2: {regexp: bidi_fails_req2, comment: <<~DESC.strip},
        Bidirectional Characters [StringPrep, ยง6], Requirement 2
        >>>
          If a string contains any RandALCat character, the string MUST NOT
          contain any LCat character.
      DESC

      BIDI_DESC_REQ3: "A string with RandALCat characters " \
                      "must start and end with RandALCat characters.",
      BIDI_FAILS_REQ3: {regexp: bidi_fails_req3, comment: <<~DESC.strip},
        Bidirectional Characters [StringPrep, ยง6], Requirement 3
        >>>
          If a string contains any RandALCat character, a RandALCat
          character MUST be the first character of the string, and a
          RandALCat character MUST be the last character of the string.
      DESC

      BIDI_FAILURE: {regexp: bidi_failure_regexp, comment: <<~DESC.strip},
        Bidirectional Characters [StringPrep, ยง6]
      DESC
    }
  end

  def profile_consts
    {
      SASLprep: %w[C.1.2 C.2.1 C.2.2 C.3 C.4 C.5 C.6 C.7 C.8 C.9],
      trace:    %w[C.2.1 C.2.2 C.3 C.4 C.5 C.6 C.8 C.9],
      nameprep: %w[C.1.2 C.2.2 C.3 C.4 C.5 C.6 C.7 C.8 C.9],
    }
      .map {|name, tables|
        {
          :"#{name.upcase}_PROHIBIT" => {
            regexp: regexp_for(*tables),
            comment: <<~DESC.strip,
              Combines #{tables.join(", ")}.
              Used by the "#{name}" profile.
            DESC
          },
          :"#{name.upcase}_PROHIBIT_STORED" => {
            union: "IN_A_1, #{name.upcase}_PROHIBIT",
            regexp: regexp_for(*tables),
            comment: <<~DESC.strip,
              Combines #{tables.join(", ")},
              and A.1.  Used by the "#{name}" profile.
            DESC
          }
        }
      }
  end

  def meta_consts
    {
      TITLES: {hash: titles, literals: false, comment: <<~DESC.strip},
        Names of each codepoint table in the RFC-3454 appendices
      DESC

      REGEXPS: {
        comment: <<~DESC.strip,
          Regexps matching each codepoint table in the RFC-3454 appendices
        DESC
        hash:     tables_to_const_names,
        literals: true,
      },

      MAPPINGS: {
        comment: <<~DESC.strip,
          Regexps and substitutions matching the RFC-3454 Appendix B tables
        DESC
        hash: {
          "B.1" => "[IN_B_1, MAP_B_1].freeze",
          "B.2" => "[IN_B_2, MAP_B_2].freeze",
          "B.3" => "[IN_B_3, MAP_B_3].freeze",
        }.freeze,
        literals: true,
      }
    }
  end

  def asgn_regexps!
    @asgn_regexps = {}
    # preset the regexp for each table
    asgn_regex "A.1", /\p{^AGE=3.2}/
    # If ruby supported all unicode properties (i.e. line break = word joiner):
    #   /[\u{00ad 034f 1806}\p{join_c}\p{VS}\p{lb=WJ}&&\p{age=3.2}]/
    asgn_table "B.1"
    asgn_table "B.2"
    asgn_table "B.3"
    asgn_regex "C.1.1", / /
    asgn_regex "C.1.2", /[\u200b\p{Zs}&&[^ ]]/
    asgn_regex "C.2.1", /[\x00-\x1f\x7f]/
    # C.2.2 is a union:
    #   Cc + Cf (as defined by Unicode 3.2) + Zl + Zp + 0xfffc
    #   - any codepoints covered by C.2.1 or C.8 or C.9
    #
    # But modern Unicode properties are significantly different, so it's better
    # to just load the table definition.
    asgn_table "C.2.2"
    asgn_regex "C.3", /\p{private use}/
    asgn_regex "C.4", /\p{noncharacter code point}/
    asgn_regex "C.5", /\p{surrogate}/
    asgn_regex "C.6", /[\p{in specials}&&\p{AGE=3.2}&&\p{^NChar}]/
    asgn_regex "C.7", /[\p{in ideographic description characters}&&\p{AGE=3.2}]/
    # C.8 is a union of \p{Bidi Control} and Unicode 3.2 properties.  But those properties
    # have changed for modern Unicode, and thus for modern ruby's regexp
    # character properties.  It's better to just load the table definition.
    asgn_table "C.8"
    asgn_regex "C.9", /[\p{in Tags}&&\p{AGE=3.2}]/
    # Unfortunately, ruby doesn't (currently) support /[\p{Bidi
    # Class=R}\p{bc=AL}]/.  On the other hand, StringPrep (based on Unicode 3.2)
    # might not be a good match for the modern (14.0) property value anyway.
    asgn_table "D.1"
    # Used to check req3 of bidirectional checks
    asgn_table "D.1", negate: true
    asgn_table "D.2"
    @asgn_regexps
  end

  def indent(str, level: 2) str.gsub(/^(?!$)/, INDENT * level) end

  def regex_str(*names, negate: false)
    "%p.freeze" % regexp_for(*names, negate: negate)
  end

  def table(name, negate: false)
    asgn_regex(name, regexp_for(name, negate: negate), negate: negate)
  end

  def asgn_table(name, negate: false)
    asgn_regex(name, regexp_for(name, negate: negate), negate: negate)
  end

  def asgn_mapping(name, replacement = @parser.mapping_tables.fetch(name))
    replacement = replacement.inspect.gsub(/" => "/, '"=>"')
    cname = name.tr(?., ?_).upcase
    "# Replacements for %s\n%s = %s.freeze" % [
      "IN_#{name}", "MAP_#{cname}", replacement,
    ]
  end

  def regexp_const_desc(name, negate: false)
    if negate then "Matches the negation of the %s table" % [name]
    else %q{%s \\StringPrep\\[\\"%s\\"]} % [titles.fetch(name), name]
    end
  end

  def const_name(prefix, table, suffix = nil)
    [prefix, table.tr(?., ?_), suffix].compact.join(?_).to_sym
  end

  def regexp_const_name(table_name, negate: false)
    const_name :IN, table_name, negate ? :NEGATED : nil
  end

  def mapping_const_name(table_name)
    const_name :MAP, table_name
  end

  def asgn_regex(name, regexp, negate: false)
    asgn_regexps[[name, negate]] = regexp
    "# %s\n%s = %p.freeze" % [
      regexp_const_desc(name, negate: negate),
      regexp_const_name(name, negate: negate), regexp,
    ]
  end

  def bidi_R_AL     ; regexp_for "D.1" end
  def bidi_not_R_AL ; regexp_for "D.1", negate: true end
  def bidi_L        ; regexp_for "D.2" end

  def bidi_fails_req2
    Regexp.union(
      /#{bidi_R_AL}.*?#{bidi_L}/mu, # RandALCat followed by LCat
      /#{bidi_L}.*?#{bidi_R_AL}/mu, # RandALCat preceded by LCat
    )
  end

  def bidi_fails_req3
    # contains RandALCat:
    Regexp.union(
      /\A#{bidi_not_R_AL}.*?#{bidi_R_AL}/mu, # but doesn't start with RandALCat
      /#{bidi_R_AL}.*?#{bidi_not_R_AL}\z/mu, # but doesn't end   with RandALCat
    )
  end

  def bidi_failure_regexp
    Regexp.union(bidi_fails_req2, bidi_fails_req3)
  end

end
